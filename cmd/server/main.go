package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"html"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
}

func faviconHandler(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "favicon not supported", http.StatusNotFound)
}

type logResponseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (l *logResponseWriter) WriteHeader(statusCode int) {
	l.statusCode = statusCode
	l.ResponseWriter.WriteHeader(statusCode)
}

type logHandler struct {
	Handler http.Handler
}

func (h *logHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	t0 := time.Now()
	l := &logResponseWriter{
		ResponseWriter: w,
		statusCode:     http.StatusOK,
	}
	h.Handler.ServeHTTP(l, r)
	d := time.Since(t0)
	log.Printf("%03d %s https://%s%s %.3fms",
		l.statusCode, r.Method,
		r.Host, r.URL, float64(d)*1e-6)
}

func main() {
	log.SetFlags(log.Ldate |
		log.Ltime |
		log.Lmicroseconds |
		log.Lshortfile |
		log.LUTC)
	host, err := os.Hostname()
	if err != nil {
		log.Fatalf("os.Hostname() error %s", err)
	}
	addr := ":8443"
	server := fmt.Sprintf("https://%s%s", host, addr)

	mux := http.DefaultServeMux
	mux.HandleFunc("/favicon.ico", faviconHandler)
	mux.HandleFunc("/", handler)

	tlsConfig := &tls.Config{
		MinVersion: tls.VersionTLS12,
		// only the assembler implementations
		CurvePreferences:         []tls.CurveID{tls.X25519, tls.CurveP256},
		PreferServerCipherSuites: true,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
		},
	}
	s := &http.Server{
		Addr:         addr,
		Handler:      &logHandler{Handler: http.DefaultServeMux},
		TLSConfig:    tlsConfig,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	go func() {
		ch := make(chan os.Signal, 1)
		signal.Notify(ch, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP)

		sig := <-ch
		log.Printf("Shutdown on signal %s", sig)
		ctx, cancel := context.WithTimeout(context.Background(),
			9*time.Second)
		defer cancel()
		err := s.Shutdown(ctx)
		if err != nil {
			log.Printf("Shutdown error %s", err)
		}
	}()

	log.Printf("start %s", server)
	// keys have been generated by mkcert
	log.Print(s.ListenAndServeTLS("server.pem", "server-key.pem"))
}
