// Server provides an example TLS server to test the new mux in a realistic
// environment.
package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/ulikunitz/mux"
)

type logResponseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (l *logResponseWriter) WriteHeader(statusCode int) {
	l.statusCode = statusCode
	l.ResponseWriter.WriteHeader(statusCode)
}

type logHandler struct {
	Handler http.Handler
}

func (h *logHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	t0 := time.Now()
	l := &logResponseWriter{
		ResponseWriter: w,
		statusCode:     http.StatusOK,
	}
	h.Handler.ServeHTTP(l, r)
	d := time.Since(t0)
	log.Printf("%03d %s https://%s%s %.3fms",
		l.statusCode, r.Method,
		r.Host, r.URL, float64(d)*1e-6)
}

type output struct {
	Host      string
	Method    string
	Path      string
	HandlerID string
	VarMap    map[string]string
}

func tcHandler(id string) http.Handler {
	h := func(w http.ResponseWriter, r *http.Request) {
		header := w.Header()
		header.Set("Content-Type", "application/json")
		out := output{
			Host:      r.Host,
			Method:    r.Method,
			Path:      r.URL.Path,
			VarMap:    mux.Vars(r),
			HandlerID: id,
		}
		data, err := json.MarshalIndent(&out, "", "  ")
		if err != nil {
			http.Error(w, fmt.Sprintf("error %s", err),
				http.StatusInternalServerError)
			return
		}

		_, err = w.Write(data)
		if err != nil {
			panic(fmt.Errorf("w.Write(data) error %s", err))

		}
	}
	return http.HandlerFunc(h)
}

func main() {
	log.SetFlags(log.Ldate |
		log.Ltime |
		log.Lmicroseconds |
		log.Lshortfile |
		log.LUTC)
	host, err := os.Hostname()
	if err != nil {
		log.Fatalf("os.Hostname() error %s", err)
	}
	addr := ":8443"
	server := fmt.Sprintf("https://%s%s", host, addr)

	m := mux.New()
	m.Handle("GET {host}/item/{itemNr}", tcHandler("1"))
	m.Handle("POST {host}/item/{itemNr}", tcHandler("2"))
	m.Handle("GET localhost/item/{itemNr}", tcHandler("3"))
	m.Handle("{method} /ding/{dingID}/dong/{dongID}", tcHandler("4"))
	m.Handle("/foo/{foo...}", tcHandler("4"))
	m.Handle("/{$}", tcHandler("5"))
	m.Handle("/a/{a2}/a", tcHandler("h2a"))
	m.Handle("/a/{a2}/b", tcHandler("h2b"))
	m.Handle("/a/{a1}/a", tcHandler("h1"))
	m.Handle("/b/{b2...}", tcHandler("b2"))
	// The following command creates a panic because the pattern is
	// redundant with the pattern above.
	// m.Handle("/b/{b1...}", tcHandler("b1"))

	tlsConfig := &tls.Config{
		MinVersion: tls.VersionTLS12,
		// only the assembler implementations
		CurvePreferences:         []tls.CurveID{tls.X25519, tls.CurveP256},
		PreferServerCipherSuites: true,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
		},
	}
	s := &http.Server{
		Addr:         addr,
		Handler:      &logHandler{Handler: m},
		TLSConfig:    tlsConfig,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	go func() {
		ch := make(chan os.Signal, 1)
		signal.Notify(ch, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP)

		sig := <-ch
		log.Printf("Shutdown on signal %s", sig)
		ctx, cancel := context.WithTimeout(context.Background(),
			9*time.Second)
		defer cancel()
		err := s.Shutdown(ctx)
		if err != nil {
			log.Printf("Shutdown error %s", err)
		}
	}()

	log.Printf("start %s", server)
	// keys have been generated by mkcert
	log.Print(s.ListenAndServeTLS("server.pem", "server-key.pem"))
}
